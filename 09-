/*
 * To find the inorder predecessor and successor of a node, the idea is to traverse the BST while tracking potential 
 * predecessor and successor candidates. Once the target node is found:
 *
 * - The inorder predecessor is determined as follows:
 *      a) If the target node has a left subtree, the predecessor is the rightmost node in that subtree.
 *      b) Otherwise, it is the last node encountered that is smaller than the target's value.
 *
 * - The inorder successor is determined as follows:
 *      a) If the target node has a right subtree, the successor is the leftmost node in that subtree.
 *      b) Otherwise, it is the last node encountered that is larger than the target's value.
 *
 * The inorder predecessor (left → root → right) is the previous node of the given node in the inorder traversal 
 * of the BST. Similarly, the inorder successor is the next node of the given node in the inorder traversal.
 *
 * **Important Note:**
 * The inorder traversal of a Binary Search Tree (BST) always produces a sorted sequence in **ascending order**.
 * This means that:
 * - The inorder predecessor of a node is the largest value smaller than the node.
 * - The inorder successor of a node is the smallest value larger than the node.
 *
 * Example BST:
 *
 *               50
 *             /    \
 *           30      70
 *          /  \    /  \
 *        20   40  60   80
 *       /         / \
 *     10        55  65
 *
 * For instance, if we search for the key 60:
 * - The inorder predecessor would be 55 (rightmost node of the left subtree of 60).
 * - The inorder successor would be 65 (leftmost node of the right subtree of 60).
 *
 * Similarly, if we search for the key 55:
 * - Inorder Predecessor of 55: 50
 * - Inorder Successor of 55: 60
 *
 */




//Optimal approach

class Solution {
    /**
     * @param inorderPredecessor An array where inorderPredecessor[0] will store the predecessor.
     * @param inorderSuccessor   An array where inorderSuccessor[0] will store the successor.
     */
    public static void findPreSuc(Node root, Node[] inorderPredecessor, Node[] inorderSuccessor, int key) {
        // Base case: If the root is null, simply return.
        if (root == null) {
            return;
        }

        // If the key is smaller than the current node, move to the left subtree.
        if (key < root.data) {
            // The current node is a potential successor.
            inorderSuccessor[0] = root;
            findPreSuc(root.left, inorderPredecessor, inorderSuccessor, key);
            return;
        }

        // If the key is greater than the current node, move to the right subtree.
        if (key > root.data) {
            // The current node is a potential predecessor.
            inorderPredecessor[0] = root;
            findPreSuc(root.right, inorderPredecessor, inorderSuccessor, key);
            return;
        }

        // If the key is found at the current node.
        
        // Find the inorder predecessor: The rightmost node in the left subtree (if exists).
        if (root.left != null) {
            Node node = root.left;
            while (node.right != null) {
                node = node.right;
            }
            inorderPredecessor[0] = node;
        }

        // Find the inorder successor: The leftmost node in the right subtree (if exists).
        if (root.right != null) {
            Node node = root.right;
            while (node.left != null) {
                node = node.left;
            }
            inorderSuccessor[0] = node;
        }
    }
}
